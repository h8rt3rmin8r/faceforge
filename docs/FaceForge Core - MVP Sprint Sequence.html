<!DOCTYPE html>
<html>
<head>
<title>FaceForge Core - MVP Sprint Sequence.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="faceforge-core---mvp-sprint-sequence">FaceForge Core - MVP Sprint Sequence</h1>
<p>Below is a sprint sequence that gets us to a shippable <strong>FaceForge Core MVP</strong> without any single sprint turning into a swamp. Each sprint is scoped so you can close it cleanly, tag a milestone, and start the next session with a fresh Copilot thread.</p>
<hr>
<h2 id="summary-concepts">SUMMARY CONCEPTS</h2>
<h3 id="mvp-definition-of-%22done%22">MVP Definition of &quot;Done&quot;</h3>
<p>A non-developer can install/run <strong>FaceForge Desktop</strong>, pick <code>FACEFORGE_HOME</code>, and then:</p>
<ul>
<li>open the local web UI (served by Core)</li>
<li>create/edit entities</li>
<li>upload assets, link them to entities, download them (streaming + resume/range)</li>
<li>run at least one real job (bulk import) and view job logs</li>
<li>enable/disable a “plugin” (manifest discovery + config surface; plugin compute not required)</li>
<li>everything binds to localhost by default with a per-install token</li>
</ul>
<p>(Aligned with the v0.2.9 spec.)</p>
<h3 id="optional-buffer-sprints-only-if-you-feel-pain">Optional “buffer” sprints (only if you feel pain)</h3>
<ul>
<li><strong>Perf &amp; indexing pass:</strong> SQLite indexes for common list queries, generated columns for frequently filtered JSON fields</li>
<li><strong>Backup/export v0:</strong> simple metadata export + asset listing (even if FFBackup becomes a plugin later)</li>
<li><strong>API polish:</strong> bulk-upsert endpoint and conflict rules, if you need it early</li>
</ul>
<h3 id="next-steps">Next Steps</h3>
<p>If you want to run this like a true sprint board, the cleanest next move is to turn each sprint into an epic, then break deliverables into 5–15 bite-sized issues each (small enough that Copilot doesn’t melt down mid-session).</p>
<hr>
<h2 id="the-sprint-sequence">THE SPRINT SEQUENCE</h2>
<hr>
<h3 id="sprint-0--repo--boring-core-scaffolding">Sprint 0 — Repo + “boring core” scaffolding</h3>
<ul>
<li>
<p><strong>Objective:</strong> Make the project easy to work on before you write real features.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>
<p>Monorepo structure (or clean multi-repo) with:</p>
<ul>
<li><code>core/</code> (FastAPI service)</li>
<li><code>desktop/</code> (Tauri)</li>
<li><code>docs/</code> (dev + user docs)</li>
</ul>
</li>
<li>
<p>Dev bootstrap scripts (one command to run Core in dev, one for UI dev if separate)</p>
</li>
<li>
<p>Formatting/linting/test harness wired (pre-commit or equivalent)</p>
</li>
<li>
<p>CI pipeline: lint + unit tests + build artifacts (at least Core)</p>
</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Fresh clone → one documented command starts Core + a placeholder <code>/healthz</code></li>
<li>CI runs on PRs without manual babysitting</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-1--config--filesystem-layout-contract">Sprint 1 — Config + filesystem layout contract</h3>
<ul>
<li>
<p><strong>Objective:</strong> Lock in how the app finds its home and writes files.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li><code>FACEFORGE_HOME</code> resolution rules + defaults</li>
<li>Directory creation rules (<code>db/</code>, <code>s3/</code>, <code>logs/</code>, <code>run/</code>, <code>config/</code>, <code>plugins/</code>)</li>
<li>Core config file format (JSON suggested in spec) + loader + validation</li>
<li>Runtime “ports.json” convention (even if Desktop owns it later)</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Core starts with only <code>FACEFORGE_HOME</code> set and creates required subfolders</li>
<li>Config changes require no code changes (just file edits)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-2--sqlite-schema-v1--id-strategy">Sprint 2 — SQLite schema v1 + ID strategy</h3>
<ul>
<li>
<p><strong>Objective:</strong> Build the relational spine cleanly before endpoints pile up.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>SQLite schema + migrations strategy (simple migration runner is fine)</li>
<li>Tables for:
<ul>
<li><code>entities</code>, <code>assets</code>, <code>entity_assets</code> (many-to-many)</li>
<li><code>relationships</code></li>
<li><code>jobs</code>, <code>job_logs</code></li>
<li><code>field_definitions</code></li>
<li><code>plugin_registry</code> (enabled/config/version snapshot)</li>
</ul>
</li>
<li>SHA-256 ID utilities:
<ul>
<li>entity IDs generated at creation time</li>
<li>asset IDs + <code>content_hash</code> computed from bytes</li>
</ul>
</li>
<li>Soft delete strategy decided (and implemented where relevant)</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>“Create entity” + “create asset record” can be done via a tiny internal script without API</li>
<li>Migration runner works from blank → latest</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-3--core-api-skeleton--auth-defaults">Sprint 3 — Core API skeleton + auth defaults</h3>
<ul>
<li>
<p><strong>Objective:</strong> A real API surface that won’t need rework later.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>FastAPI app structure with versioned routing (<code>/v1/...</code>)</li>
<li>Token auth middleware (per-install token stored in config; localhost by default)</li>
<li>Standard response envelope + error model (consistent errors matter)</li>
<li><code>/docs</code> and <code>/redoc</code> enabled and accurate</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>A request without token fails (except health endpoints you explicitly exempt)</li>
<li>OpenAPI renders and matches real routes</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-4--entities-crud--listsearch-primitives">Sprint 4 — Entities CRUD + list/search primitives</h3>
<ul>
<li>
<p><strong>Objective:</strong> The simplest “real feature” end-to-end.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Endpoints:
<ul>
<li><code>GET /v1/entities</code></li>
<li><code>POST /v1/entities</code></li>
<li><code>GET/PATCH/DELETE /v1/entities/{entity_id}</code></li>
</ul>
</li>
<li>Minimal filtering/paging/sorting (don’t overbuild search yet)</li>
<li>Entity model supports: <code>display_name</code>, <code>aliases</code>, <code>tags</code>, <code>fields</code> JSON, timestamps</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>You can create 100 entities and page through them</li>
<li>Patch updates only touched fields; timestamps behave sensibly</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-5--assets-v1-upload-metadata-linkunlink-download-filesystem-provider">Sprint 5 — Assets v1: upload, metadata, link/unlink, download (filesystem provider)</h3>
<ul>
<li>
<p><strong>Objective:</strong> Make file ingest + retrieval rock-solid before adding S3.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Storage abstraction interface + <strong>local filesystem provider</strong> implementation</li>
<li><code>POST /v1/assets/upload</code> (multipart; optional companion <code>_meta.json</code>)</li>
<li><code>GET /v1/assets/{asset_id}</code> metadata</li>
<li>Link/unlink endpoints to entities</li>
<li><code>GET /v1/assets/{asset_id}/download</code>:
<ul>
<li>streaming response</li>
<li>HTTP range support (resume-friendly)</li>
</ul>
</li>
<li><strong>IMPORTANT</strong>: Ingest metadata extraction via <a href="https://exiftool.org/">exiftool</a>
<ul>
<li>Embed <code>exiftool</code> binary (avoid Perl requirements) - install the correct edition per OS (this should be incorporated into the install process later)</li>
<li>Run on asset upload to extract metadata
<ul>
<li>Store in asset record under <code>metadata</code> JSON field</li>
<li>Spawn parallel process to run <code>exiftool</code> if needed (be sure to log events properly)</li>
<li>EXCEPTIONS (Files matching these patterns should skip exiftool processing):
<ul>
<li><code>_(meta|directorymeta)\.json$</code></li>
<li><code>\.(cover|thumb|thumb(s|db|index|nail))$</code></li>
<li><code>^(thumb|thumb(s|db|index|nail))\.db$</code></li>
<li><code>\.(csv|html?|json|tsv|xml)$</code></li>
</ul>
</li>
</ul>
</li>
<li>Send parameters to exiftool via parameter file: <code>exiftool -@ &quot;$ArgsFile&quot; 2&gt; $null</code> (in PowerShell, for example)</li>
<li>Use these exact parameters in the <code>$ArgsFile</code>:<pre class="hljs"><code><div>-quiet -extractEmbedded3 -scanForXMP -unknown2 -json -G3:1 -struct -b -ignoreMinorErrors -charset filename=utf8 -api requestall=3 -api largefilesupport=1 --
</div></code></pre>
</li>
<li>Parse the output and <strong>REMOVE</strong> the following keys from the JSON before storing:
<ul>
<li><code>ExifTool:ExifToolVersion</code></li>
<li><code>ExifTool:FileSequence</code></li>
<li><code>ExifTool:NewGUID</code></li>
<li><code>System:BaseName</code></li>
<li><code>System:Directory</code></li>
<li><code>System:FileBlockCount</code></li>
<li><code>System:FileBlockSize</code></li>
<li><code>System:FileDeviceID</code></li>
<li><code>System:FileDeviceNumber</code></li>
<li><code>System:FileGroupID</code></li>
<li><code>System:FileHardLinks</code></li>
<li><code>System:FileInodeNumber</code></li>
<li><code>System:FileName</code></li>
<li><code>System:FilePath</code></li>
<li><code>System:FilePermissions</code></li>
<li><code>System:FileUserID</code></li>
</ul>
</li>
<li>The final resulting JSON data (<code>$ExifToolOutput</code>) must be validated as proper JSON and being not-empty and nested into the following structure before storing:<pre class="hljs"><code><div>{
    <span class="hljs-attr">"Source"</span>: <span class="hljs-string">"ExifTool"</span>,
    <span class="hljs-attr">"Type"</span>: <span class="hljs-string">"JsonMetadata"</span>,
    <span class="hljs-attr">"Name"</span>: $<span class="hljs-literal">null</span>,
    <span class="hljs-attr">"NameHashes"</span>: $<span class="hljs-literal">null</span>,
    <span class="hljs-attr">"Data"</span>: {ExifToolOutput}
}
</div></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Upload a 2–5GB file and download it reliably</li>
<li>Range requests work (spot-check with curl / a download manager)</li>
<li>Uploaded asset gets metadata extracted and stored correctly (with proper error handling/logging/validation)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-6--seaweedfs-provider--default-local-s3-wiring">Sprint 6 — SeaweedFS provider + “default local S3” wiring</h3>
<ul>
<li>
<p><strong>Objective:</strong> Bring the spec’s default object storage online without dragging Desktop into it yet.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>SeaweedFS “managed binary” contract defined (paths, args, health checks)</li>
<li>S3-compatible provider implementation via SeaweedFS endpoint</li>
<li>Storage routing rules (by asset <code>kind</code> or size threshold) working</li>
<li>Core can operate even if SeaweedFS is disabled (fallback to filesystem provider)</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>With SeaweedFS running: uploads land in the S3 backend</li>
<li>With SeaweedFS off: uploads still work (filesystem)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-7--descriptors--field-definitions-admin">Sprint 7 — Descriptors + Field Definitions (admin)</h3>
<ul>
<li>
<p><strong>Objective:</strong> Get the “flexible schema without migrations” concept working.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Field definition endpoints:
<ul>
<li><code>GET/POST/PATCH/DELETE /v1/admin/field-defs...</code></li>
</ul>
</li>
<li>Descriptor endpoints:
<ul>
<li><code>GET/POST /v1/entities/{entity_id}/descriptors</code></li>
<li><code>PATCH/DELETE /v1/descriptors/{descriptor_id}</code></li>
</ul>
</li>
<li>Validation driven by field definitions (at least type + required + regex/options)</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Add a new field definition → UI/API accepts it immediately</li>
<li>Invalid descriptor values are rejected with clear errors</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-8--relationships--relation-type-suggestion">Sprint 8 — Relationships + relation type suggestion</h3>
<ul>
<li>
<p><strong>Objective:</strong> Relationship metadata, without graph visualization.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li><code>POST /v1/relationships</code> and <code>GET /v1/relationships?entity_id=...</code></li>
<li><code>DELETE /v1/relationships/{relationship_id}</code></li>
<li><code>GET /v1/relation-types?query=...</code> backed by:
<ul>
<li>existing relationship types in DB</li>
<li>a small built-in seed list (so first-time UX isn’t empty)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Create relationship types organically; suggestion endpoint surfaces them</li>
<li>Relationship records round-trip correctly and are queryable</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-9--jobs--structured-logs--one-real-job">Sprint 9 — Jobs + structured logs + one “real” job</h3>
<ul>
<li>
<p><strong>Objective:</strong> A durable job model that plugins can piggyback on later.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li><code>POST /v1/jobs</code>, <code>GET /v1/jobs/{job_id}</code>, <code>GET /v1/jobs/{job_id}/log</code>, <code>POST /v1/jobs/{job_id}/cancel</code></li>
<li>Append-only structured logging with timestamps + levels</li>
<li>Progress reporting fields (percent + step name)</li>
<li>Implement <strong>one Core job</strong> end-to-end:
<ul>
<li><code>assets/bulk-import</code> as a job (directory scan + sidecar <code>_meta.json</code>)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Start bulk import → watch progress/logs live → job completes</li>
<li>Cancellation behaves predictably (stops work, marks state)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-10--plugin-foundations-v1-discovery--registry--config-surface">Sprint 10 — Plugin foundations v1 (discovery + registry + config surface)</h3>
<ul>
<li>
<p><strong>Objective:</strong> “Plugins exist” without building plugin compute yet.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Plugin manifest format (<code>plugin.json</code>) and loader</li>
<li>Discovery from <code>${FACEFORGE_HOME}/plugins</code></li>
<li>Registry persisted in DB:
<ul>
<li>enabled/disabled</li>
<li>stored config blob (validated against JSON schema if provided)</li>
</ul>
</li>
<li>API:
<ul>
<li><code>GET /v1/plugins</code></li>
<li>enable/disable</li>
<li><code>GET/PUT /v1/plugins/{id}/config</code></li>
</ul>
</li>
<li>Namespacing rules established (<code>/v1/plugins/&lt;id&gt;/...</code> reserved)</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Drop a manifest into plugins dir → it appears in API/UI</li>
<li>Enable/disable state persists across restarts</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-11--core-web-ui-mvp-core-only-features">Sprint 11 — Core Web UI MVP (Core-only features)</h3>
<ul>
<li>
<p><strong>Objective:</strong> A usable UI that covers everything Core can do (no “backend-only” gaps).</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Pages:
<ul>
<li>Entities list (table + gallery toggle)</li>
<li>Entity detail with tabs: Overview / Descriptors / Attachments / Relationships</li>
<li>Jobs page: list + detail log view</li>
<li>Plugins page: list + enable/disable + config form rendering (basic)</li>
</ul>
</li>
<li>Attachments UX:
<ul>
<li>upload</li>
<li>link/unlink</li>
<li>download</li>
</ul>
</li>
<li>Lightweight styling, fast load, no runtime Node dependency</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>A non-technical user can do the whole “create entity → upload asset → link → download” loop without touching API tools</li>
<li>Jobs are viewable and understandable from UI</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-12--desktop-shell-mvp-tauri-orchestrator--tray-ux">Sprint 12 — Desktop shell MVP (Tauri orchestrator + tray UX)</h3>
<ul>
<li>
<p><strong>Objective:</strong> Make it run like a real app, not a repo full of scripts.</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>First-run wizard:
<ul>
<li>choose <code>FACEFORGE_HOME</code></li>
<li>choose/auto-pick Core port (and SeaweedFS port if needed)</li>
</ul>
</li>
<li>Process orchestration:
<ul>
<li>start/stop Core service</li>
<li>start/stop SeaweedFS (if enabled)</li>
<li>basic health monitoring + restart strategy</li>
</ul>
</li>
<li>Tray behavior:
<ul>
<li>close to tray (not exit)</li>
<li>menu: Open UI, Status, Logs, Stop, Restart, Exit</li>
<li>on exit: prompt to stop services or leave running</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Double-click app → wizard → “Open UI” works</li>
<li>Closing window leaves tray running; Exit performs expected shutdown behavior</li>
</ul>
</li>
</ul>
<hr>
<h3 id="sprint-13--packaging--release-hardening">Sprint 13 — Packaging + release hardening</h3>
<ul>
<li>
<p><strong>Objective:</strong> Turn “works on my machine” into “ship it.”</p>
</li>
<li>
<p><strong>Deliverables</strong></p>
<ul>
<li>Packaging plan implemented:
<ul>
<li>Core service shipped as frozen binary or embedded Python runtime (pick one and commit)</li>
<li>SeaweedFS binaries bundled or fetched in a controlled way</li>
</ul>
</li>
<li>Installer / portable bundle per OS (Windows first if that’s your priority)</li>
<li>Logging + crash reports in <code>${FACEFORGE_HOME}/logs</code></li>
<li>Security defaults verified:
<ul>
<li>localhost bind by default</li>
<li>token required</li>
<li>config/secrets not accidentally committed</li>
</ul>
</li>
<li>“First-run screenshots + quickstart” user docs</li>
</ul>
</li>
<li>
<p><strong>Acceptance</strong></p>
<ul>
<li>Clean machine install → user completes wizard → app works without dev tooling</li>
<li>Basic smoke test checklist passes reliably</li>
</ul>
</li>
</ul>
<hr>

</body>
</html>
